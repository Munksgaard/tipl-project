\documentclass[runningheads,a4paper]{llncs}

%% Encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%% symbols, graphics, etc
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}

%% Authors and other title stuff
\title{Implementing and Solving a Contact Dynamics Problem on the GPU}
\titlerunning{Contact Dynamics on GPU}

\author{Philip Munksgaard \and Thorbjørn S. Kaiser}
\authorrunning{P. Munksgaard \and T. S. Kaiser}

\institute{
    University of Copenhagen Department of Computer Science (DIKU), \\
    Nørre Campus, Universitetsparken 5, DK-2100 Copenhagen Ø, Denmark
}

\begin{document}
\mainmatter
\maketitle

\begin{abstract}
abstract
\end{abstract}

\section{First Section}
\section{Introduction}

This report describes the design and implementation of a parallel Jacobi solver
for a contact dynamics problem in Haskell. The goal of this project has been to
compute the contact impulses between rigid bodies in a 2-dimensional system
using Accelerate, a Haskell embedded language for general purpose GPU
programming (GPGPU). To do so, and to assess the efficiency of the parallel
implementation, we also implemented the Jacobi solver, as well as an iterative
Gauss-Seidel solver, in regular Haskell.

% Thanks to Vincent and Martin?

\section{Motivation}

Simulating bodies in a system is easy, as long as no interactions between
bodies occur, eg. there are no collision. In that case, the acceleration of an
object is linearly proportional to its mass and any external forces that act
upon it. However, when rigid bodies collide there is a nonsmooth relationship
between velocities and forces that have to be handled. In complex systems with
many bodies, these collisions become very numerous, and calculating the
resulting changes in movement of the bodies become computationally expensive.

% Maybe a nice drawing of bodies flying around with no collision and then one
% with collisions?

To overcome this, we focus on computing the impulses between bodies in contact
in a given configuration of a system. Imagine a system like the one in figure
\ref{fig:pyr2simple}. It consists of three discs with unit mass and radius,
numbered from 0 to 2, in a 2-dimensional system, forming a pyramid of two
layers. Additionally there are three contacts between the bodies, named $a$,
$b$, and $c$. If there are no external forces acting upon the discs, they will
stay perfectly still and there will be no impulses. Now, imagine that we apply
a downward force to disc 0. Intuitively, we would expect that to result in an
impulse that acts upon both disc 1 and disc 2, meaning that contacts $a$ and
$b$ should have an impulse. However, we would not expect contact $c$ to have an
impulse, as discs 1 and to would be pushed away from each other.

\begin{figure}
  \centering
  \includegraphics{figures/pyr2simple.png}
  \caption{A simple 2 layered pyramid.}
  \label{pyr2simple}
  % TODO: More figures? One with a downward arrow and the resulting impulses?
\end{figure}

Naturally, the more layers we add to our pyramids, the more complex these
interactions become, since we have to more contacts into account. For example,
in figure \ref{fig:pyr4-0}, to compute the impulse of the contact between discs
5 and 8, we have to take into accounts all the forces that act upon those two
discs. In particular, to compute the contact impulse between disc 5 and 8 we
have to take into account the contact impulses of all the disc-pairs $(2;5)$,
$(4;5)$, $(5;9)$, $(4;8)$, $(7;8)$, and $(8;9)$. Furthermore, we have to
translate the impulses in these adjacent contacts to the contact-space of the
contact between disc 5 and 8, in order to actually know what the contribution
is.

As can easily be imagined for this particular problem, the more layers we add,
the more contacts there are~\footnote{In fact, for a height $n$, we have
  exactly $\frac{3n}{2}(n-1)$ contacts: Each layer introduces $2n-2$ contacts
  between the new layer and the old, in addition to the $n-1$ contacts in the
  new layer. We can then prove the above by induction.}, and for each contact,
we have to take up to 10 other contacts into account when calculating its
impulse, as can easily be seen in figure \ref{fig:upto10}. Furthermore, as
contact impulses depend on adjacent contact impulses, we cannot easily
calculate an analytical solution. Instead, we have to compute the solution
numerically, by using intermediate estimates to iteratively produces better and
better estimates for the contact impulses until we reach convergence.

Because of the massive size of these problems, and the iterative nature of the
solver, computing the contact impulses in large pyramids is expensive on
traditional sequential architectures. We wish to explore the possibility and
efficiency of computing these contact dynamics by using the data parallel
architecture of GPUs.

\section{Goals}

We wish to calculate the contact impulses between discs in a 2-dimensional
system using Accelerate, a Haskell embedded language for expressing parallel
computations suitable for execution on a GPU. Since transferring data to and
from the GPU can incur significant overhead, and GPU programming in general
imposes constraints on how computations can be done, we also wish to run
performance tests, comparing the GPGPU implementation with implementations of
the solver running on traditional sequential hardware, in order to discuss the
efficiency of the implementation.
\end{document}
